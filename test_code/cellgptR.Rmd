---
title: "R Notebook"
output: html_notebook
---





```{r}
install.packages("openai")
remotes::install_github("Winnie09/GPTCelltype")
```


```{r}
library(dplyr)
library(Seurat)
library(patchwork)


data=readRDS("C:/Users/ellio/OneDrive - UW-Madison/Jack/combined_seurat_object_filtered.RDS")
Idents(data)=data$sample
Idents(data) %>% table
data=JoinLayers(data)
data=NormalizeData(data)
markers=FindAllMarkers(data)




```


```{r}
# Load required libraries
library(tidyverse)
library(readr)

# Read the CSV file
data <- read_csv("C:/Users/ellio/OneDrive - UW-Madison/cellgpt_final_folder/test_code/top_markers_broad_cell_type.csv")


# Function to process the data
process_data <- function(data) {
  data %>%
    separate_rows(`Top 10 Markers`, sep = ", ") %>%
    rename(cluster = `Broad cell type`, gene = `Top 10 Markers`)
}

# Apply the function to process the data
result <- process_data(data)

# Set gene as row names
result_with_rownames <- result %>%
  column_to_rownames(var = "gene")

# Display the first few rows of the result
print(head(result_with_rownames))

# Optionally, save the result to a CSV file
write_csv(result, "findallmarkers_style_output.csv")

```

```{r}
df_expanded <- data %>%
  slice(rep(1:n(), each = 10)) %>%
  mutate(marker_index = rep(1:10, times = n()/10))

```


```{r}
library(tidyr)
library(dplyr)

# Step 1: Separate the markers
df_long <- data %>%
  mutate(markers = strsplit(as.character(markers), ", "))






# Step 2: Rename columns and create the cluster column
df_reshaped <- df_long %>%
  rename(cluster = `group`, marker = markers) %>%
  select(cluster, marker)

# Display the first few rows of the reshaped dataframe
head(df_reshaped, 10)
```


```{r}

```



```{r}
# Load required libraries
library(tidyverse)
library(readr)


# Print column names to check
print("Column names in the CSV:")
print(colnames(data))

# Function to process the data
process_data <- function(data) {
  # Identify the column names
  cell_type_col <- grep("cell type|celltype", colnames(data), ignore.case = TRUE, value = TRUE)
  markers_col <- grep("marker", colnames(data), ignore.case = TRUE, value = TRUE)
  
  if (length(cell_type_col) == 0 || length(markers_col) == 0) {
    stop("Could not identify the correct columns. Please check your CSV file.")
  }
  
  data %>%
    select(all_of(c(cell_type_col, markers_col))) %>%
    separate_rows(all_of(markers_col), sep = ",//s*") %>%
    rename(cluster = all_of(cell_type_col), gene = all_of(markers_col))
}

# Apply the function to process the data
result <- tryCatch({
  process_data(data)
}, error = function(e) {
  print(paste("Error occurred:", e$message))
  print("Printing first few rows of the original data:")
  print(head(data))
  stop("Script execution halted due to error.")
})

# Display the first few rows of the result
print("First few rows of the processed data:")
print(head(result))

# Optionally, save the result to a CSV file
write_csv(result, "findallmarkers_style_output.csv")

print("Script completed. Output saved to 'findallmarkers_style_output.csv'")
```


```{r}
library(openai)


identify_cell_types <- function(input_data, tissuename = NULL, model = "gpt-4", topgenenumber = 10) {
 OPENAI_API_KEY <- Sys.getenv("OPENAI_API_KEY")
  if (OPENAI_API_KEY == "") {
    print("Note: OpenAI API key not found: returning the prompt itself.")
    API.flag <- 0
  } else {
    API.flag <- 1
  }

  # Process input data
  if (is.data.frame(input_data)) {
    input <- paste(input_data$`Broad cell type`, input_data$`Top 10 Markers`, sep = ": ")
  } else if (is.list(input_data)) {
    input <- sapply(names(input_data), function(name) {
      paste(name, paste(input_data[[name]][1:topgenenumber], collapse = ", "), sep = ": ")
    })
  } else {
    stop("Input must be a data frame or a list")
  }

  if (!API.flag) {
    message <- paste0("Identify cell types of ", tissuename, 
      " cells using the following markers separately for each/n row. Only provide the cell type name. Do not show numbers before the name./n Some can be a mixture of multiple cell types. ", 
      "/n", paste(input, collapse = "/n"))
    return(message)
  } else {
    print("Note: OpenAI API key found: returning the cell type annotations.")
    cutnum <- ceiling(length(input)/30)
    cid <- if (cutnum > 1) as.numeric(cut(1:length(input), cutnum)) else rep(1, length(input))

    allres <- sapply(1:cutnum, function(i) {
      id <- which(cid == i)
      flag <- 0
      while (flag == 0) {
        k <- openai::create_chat_completion(
          model = model, 
          messages = list(list(
            role = "user", 
            content = paste0("Identify cell types of ", tissuename, 
              " cells using the following markers separately for each/n row. Only provide the cell type name. Do not show numbers before the name./n Some can be a mixture of multiple cell types./n", 
              paste(input[id], collapse = "/n"))
          ))
        )
        res <- strsplit(k$choices$message$content, "/n")[[1]]
        if (length(res) == length(id)) flag <- 1
      }
      names(res) <- names(input)[id]
      res
    }, simplify = FALSE)

    print("Note: It is always recommended to check the results returned by GPT-4 in case of/n AI hallucination, before going to down-stream analysis.")
    return(gsub(",$", "", unlist(allres)))
  }
}
```



```{r}

results <- identify_cell_types(data, tissuename = "lung")
```



```{r}

# IMPORTANT! Assign your OpenAI API key. See Vignette for details
Sys.setenv(OPENAI_API_KEY = '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')

# Load packages
library(GPTCelltype)
library(openai)








# Assume you have already run the Seurat pipeline https://satijalab.org/seurat/
# "obj" is the Seurat object; "markers" is the output from FindAllMarkers(obj)
# Cell type annotation by GPT-4
res <- gptcelltype(markers, model = 'gpt-4')






# Assign cell type annotation back to Seurat object
obj@meta.data$celltype <- as.factor(res[as.character(Idents(obj))])

# Visualize cell type annotation on UMAP
DimPlot(obj,group.by='celltype')
```



```{r}

# Define the function
process_test_board <- function(file_path) {
  
  # Read the CSV file
  test_board <- read.csv(file_path)
  
  # Rename the columns
  colnames(test_board)[colnames(test_board) == "group"] <- "cluster"
  colnames(test_board)[colnames(test_board) == "logfoldchanges"] <- "avg_log2FC"
  colnames(test_board)[colnames(test_board) == "names"] <- "gene"
  
  # Assuming gptcelltype is a function that takes a dataframe and a model
  res <- gptcelltype(test_board, model = 'gpt-4o')
  
  # Return the result
  return(res)
}




# Example usage:
result_broad <- process_test_board("C:/Users/ellio/OneDrive - UW-Madison/cellgpt_final_folder/test_code/default_markers_broad_cell_type.csv")

result_broad


# Fully correct: 7
# Partially correct: 4
# Incorrect: 4

result_granular <- process_test_board("C:/Users/ellio/OneDrive - UW-Madison/cellgpt_final_folder/test_code/default_markers_granular_cell_type.csv")

result_granular


# Fully correct: 11
# Partially correct: 3
# Incorrect: 6


#USe LLM to benchmarker

```

#CellGPT
```{r}






```



#GPT4annotator
##Jack'sdata

```{r}
library(GPTCelltype)
library(openai)

res_jack <- gptcelltype(data_merge_marker, model = 'gpt-4o')

res_jack

res_jack <- gptcelltype(data_merge_marker, model = 'gpt-4')


data_merge$clustering_monocle3 %>% table
res_jack


cluster_to_celltype <- c(
  "1" = "Macrophages",
  "2" = "Fibroblasts",
  "3" = "Neurons",
  "4" = "Proliferating Cells",
  "5" = "Epithelial Cells",
  "6" = "Endothelial Cells",
  "7" = "Macrophages",
  "8" = "Epithelial Cells",
  "9" = "Mitochondrial Cells",
  "10" = "T Cells",
  "11" = "Smooth Muscle Cells",
  "12" = "Neurons",
  "13" = "Epithelial Cells"
)


cluster_to_celltype <- c(
  `1` = "Macrophages",
  `2` = "Fibroblasts",
  `3` = "Neurons",
  `4` = "Proliferating Cells",
  `5` = "Epithelial Cells",
  `6` = "Endothelial Cells",
  `7` = "Macrophages",
  `8` = "Epithelial Cells",
  `9` = "Mitochondrial Cells",
  `10` = "T Cells",
  `11` = "Smooth Muscle Cells",
  `12` = "Neurons",
  `13` = "Epithelial Cells"
)



# Add the new column to the Seurat object

columbia_cell_type_annotati=cluster_to_celltype[data_merge$clustering_monocle3]
columbia_cell_type_annotati=as.data.frame(columbia_cell_type_annotati)
data_merge$columbia_cell_type_annotation <- t(columbia_cell_type_annotati)
# Verify the new column
table(data_merge$columbia_cell_type_annotation)




DimPlot(data_merge,group.by = "columbia_cell_type_annotation",reduction = "umap_harmony_notheta",label=TRUE,split.by = "sample")



```



#Sctype
##jack's data



```{r}
auto_detect_tissue_type=function(path_to_db_file, seuratObject, scaled, assay = "RNA"){
    
    # get all tissue types in DB
    db_read = openxlsx::read.xlsx(path_to_db_file); tissues_ = unique(db_read$tissueType); result_ = c()
    
    for(tissue in tissues_){ print(paste0("Checking...", tissue));
        
        # prepare gene sets
        gs_list = gene_sets_prepare(path_to_db_file, tissue);

        # check Seurat version
        package_type <- substr(packageVersion("Seurat"), 1, 1)
        data_type <- if (scaled) "scale.data" else "counts"
         obj <- if (package_type == "5") {
          as.matrix(seuratObject[[assay]][data_type])
        } else {
          as.matrix(slot(seuratObject[[assay]], data_type))
        } 
        
        es.max = sctype_score(scRNAseqData = obj, scaled = scaled, gs = gs_list$gs_positive, gs2 = gs_list$gs_negative, 
                              marker_sensitivity = gs_list$marker_sensitivity, verbose=!0);
        
        cL_resutls = do.call("rbind", lapply(unique(seuratObject@meta.data$clustering_monocle3), function(cl){
            
            es.max.cl = sort(rowSums(es.max[ ,rownames(seuratObject@meta.data[seuratObject@meta.data$clustering_monocle3==cl, ])]), decreasing = !0)
            head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl), 10)
        }))
        
        dt_out = cL_resutls %>% group_by(cluster) %>% top_n(n = 1)
        
        # return mean score for tissue
        result_ = rbind(result_, data.frame(tissue = tissue, score = mean(dt_out$scores)))
    }
    
    # order by mean score
    result_ = result_[order(-result_$score),]
    
    # plot 
    barplot(height=result_$score, names=result_$tissue, col=rgb(0.8,0.1,0.1,0.6),
            xlab="Tissue", ylab="Summary score",  main="The higher summary score, the more likely tissue type is")
    
    result_
}


# load gene set preparation function
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R")
# load cell type annotation function
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R")
# load auto-detection function
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/auto_detect_tissue_type.R")

```

```{r}
# check Seurat object version (scRNA-seq matrix extracted differently in Seurat v4/v5)
seurat_package_v5 <- isFALSE('counts' %in% names(attributes(data_merge[["RNA"]])));
print(sprintf("Seurat object %s is used", ifelse(seurat_package_v5, "v5", "v4")))


# guess a tissue type
tissue_guess <- auto_detect_tissue_type(path_to_db_file = db_, seuratObject = data_merge, scaled = TRUE, assay = "RNA")  # if saled = TRUE, make sure the data is scaled, as seuratObject[[assay]]@scale.data is used. If you just created a Seurat object, without any scaling and normalization, set scaled = FALSE, seuratObject[[assay]]@counts will be used 

db_ <- "https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_full.xlsx";

```


```{r}
# DB file

tissue <- "Liver" # e.g. Immune system,Pancreas,Liver,Eye,Kidney,Brain,Lung,Adrenal,Heart,Intestine,Muscle,Placenta,Spleen,Stomach,Thymus 
# prepare gene sets

gs_list <- gene_sets_prepare(db_, tissue)

# extract scaled scRNA-seq matrix
scRNAseqData_scaled <- if (seurat_package_v5) as.matrix(data_merge[["RNA"]]$scale.data) else as.matrix(data_merge[["RNA"]]@scale.data)

# run ScType
es.max <- sctype_score(scRNAseqData = scRNAseqData_scaled, scaled = TRUE, gs = gs_list$gs_positive, gs2 = gs_list$gs_negative)


# merge by cluster
cL_resutls <- do.call("rbind", lapply(unique(data_merge@meta.data$clustering_monocle3), function(cl){
    es.max.cl = sort(rowSums(es.max[ ,rownames(data_merge@meta.data[data_merge@meta.data$clustering_monocle3==cl, ])]), decreasing = !0)
    head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, ncells = sum(data_merge@meta.data$clustering_monocle3==cl)), 10)
}))


sctype_scores <- cL_resutls %>% group_by(cluster) %>% top_n(n = 1, wt = scores)


# set low-confident (low ScType score) clusters to "unknown"
sctype_scores$type[as.numeric(as.character(sctype_scores$scores)) < sctype_scores$ncells/4] <- "Unknown"




data_merge@meta.data$sctype_classification_liver = ""
for(j in unique(sctype_scores$cluster)){
  cl_type = sctype_scores[sctype_scores$cluster==j,]; 
  data_merge@meta.data$sctype_classification_liver[data_merge@meta.data$clustering_monocle3 == j] = as.character(cl_type$type[1])
}


data_merge$clustering_monocle3
```


```{r}
DimPlot(data_merge,group.by = "clustering_monocle3",reduction = "umap_harmony_notheta",label=TRUE)
DimPlot(data_merge,group.by = "sctype_classification",reduction = "umap_harmony_notheta",label=TRUE)
DimPlot(data_merge,group.by = "columbia_cell_type_annotation",reduction = "umap_harmony_notheta",label=TRUE)
DimPlot(data_merge,group.by = "sctype_classification_liver",reduction = "umap_harmony_notheta",label=TRUE)
```








